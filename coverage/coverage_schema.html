
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/remiges-tech/crux/db/pg.go (75.0%)</option>
				
				<option value="file1">github.com/remiges-tech/crux/db/sqlc-gen/db.go (100.0%)</option>
				
				<option value="file2">github.com/remiges-tech/crux/db/sqlc-gen/models.go (23.1%)</option>
				
				<option value="file3">github.com/remiges-tech/crux/db/sqlc-gen/ruleset.sql.go (0.0%)</option>
				
				<option value="file4">github.com/remiges-tech/crux/db/sqlc-gen/schema.sql.go (76.0%)</option>
				
				<option value="file5">github.com/remiges-tech/crux/db/sqlc-gen/wfinstance.sql.go (0.0%)</option>
				
				<option value="file6">github.com/remiges-tech/crux/server/schema/schema_delete.go (68.0%)</option>
				
				<option value="file7">github.com/remiges-tech/crux/server/schema/schema_get.go (68.0%)</option>
				
				<option value="file8">github.com/remiges-tech/crux/server/schema/schema_list.go (60.0%)</option>
				
				<option value="file9">github.com/remiges-tech/crux/server/schema/schema_new.go (81.1%)</option>
				
				<option value="file10">github.com/remiges-tech/crux/server/schema/schema_update.go (67.0%)</option>
				
				<option value="file11">github.com/remiges-tech/crux/testutils/test_utils.go (75.0%)</option>
				
				<option value="file12">github.com/remiges-tech/crux/types/types.go (40.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pg

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

func NewProvider(connString string) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        ctx := context.Background()
        connPool, err := pgxpool.New(ctx, connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = connPool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return connPool, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov8" title="1">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package sqlc

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type BrwfEnum string

const (
        BrwfEnumB BrwfEnum = "B"
        BrwfEnumW BrwfEnum = "W"
)

func (e *BrwfEnum) Scan(src interface{}) error <span class="cov8" title="1">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = BrwfEnum(s)</span>
        case string:<span class="cov8" title="1">
                *e = BrwfEnum(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for BrwfEnum: %T", src)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type NullBrwfEnum struct {
        BrwfEnum BrwfEnum `json:"brwf_enum"`
        Valid    bool     `json:"valid"` // Valid is true if BrwfEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBrwfEnum) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.BrwfEnum, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.BrwfEnum.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullBrwfEnum) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.BrwfEnum), nil</span>
}

type App struct {
        ID          int32            `json:"id"`
        Realm       string           `json:"realm"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
}

type Capgrant struct {
        ID        int32            `json:"id"`
        Realm     int32            `json:"realm"`
        User      string           `json:"user"`
        App       pgtype.Text      `json:"app"`
        Cap       string           `json:"cap"`
        From      pgtype.Timestamp `json:"from"`
        To        pgtype.Timestamp `json:"to"`
        Setat     pgtype.Timestamp `json:"setat"`
        Setby     string           `json:"setby"`
        Isdeleted pgtype.Bool      `json:"isdeleted"`
}

type Config struct {
        Realm int32            `json:"realm"`
        Slice int32            `json:"slice"`
        Name  string           `json:"name"`
        Descr string           `json:"descr"`
        Val   pgtype.Text      `json:"val"`
        Ver   pgtype.Int4      `json:"ver"`
        Setby string           `json:"setby"`
        Setat pgtype.Timestamp `json:"setat"`
}

type Deactivated struct {
        ID      int32            `json:"id"`
        Realm   string           `json:"realm"`
        User    pgtype.Text      `json:"user"`
        Deactby string           `json:"deactby"`
        Deactat pgtype.Timestamp `json:"deactat"`
}

type Realm struct {
        ID          int32            `json:"id"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
        Payload     []byte           `json:"payload"`
}

type Realmslice struct {
        ID           int32            `json:"id"`
        Realm        string           `json:"realm"`
        Descr        string           `json:"descr"`
        Active       bool             `json:"active"`
        Activateat   pgtype.Timestamp `json:"activateat"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
}

type Ruleset struct {
        ID         int32            `json:"id"`
        Realm      int32            `json:"realm"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Brwf       BrwfEnum         `json:"brwf"`
        Class      string           `json:"class"`
        Setname    string           `json:"setname"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Ruleset    []byte           `json:"ruleset"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

type Schema struct {
        ID            int32            `json:"id"`
        Realm         int32            `json:"realm"`
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Brwf          BrwfEnum         `json:"brwf"`
        Class         string           `json:"class"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

type Stepworkflow struct {
        Slice    int32       `json:"slice"`
        App      pgtype.Text `json:"app"`
        Step     string      `json:"step"`
        Workflow string      `json:"workflow"`
}

type Wfinstance struct {
        ID       int32            `json:"id"`
        Entityid string           `json:"entityid"`
        Slice    int32            `json:"slice"`
        App      string           `json:"app"`
        Class    string           `json:"class"`
        Workflow string           `json:"workflow"`
        Step     string           `json:"step"`
        Loggedat pgtype.Timestamp `json:"loggedat"`
        Doneat   pgtype.Timestamp `json:"doneat"`
        Nextstep string           `json:"nextstep"`
        Parent   pgtype.Int4      `json:"parent"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: ruleset.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const getApp = `-- name: GetApp :one
SELECT app
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND brwf = 'W'
`

type GetAppParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
}

func (q *Queries) GetApp(ctx context.Context, arg GetAppParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getApp, arg.Slice, arg.App, arg.Class)
        var app string
        err := row.Scan(&amp;app)
        return app, err
}</span>

const getClass = `-- name: GetClass :one
SELECT class
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND brwf = 'W'
`

type GetClassParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
}

func (q *Queries) GetClass(ctx context.Context, arg GetClassParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getClass, arg.Slice, arg.App, arg.Class)
        var class string
        err := row.Scan(&amp;class)
        return class, err
}</span>

const getWFActiveStatus = `-- name: GetWFActiveStatus :one
SELECT is_active
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND brwf = 'W'
    AND setname = $4
`

type GetWFActiveStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFActiveStatus(ctx context.Context, arg GetWFActiveStatusParams) (pgtype.Bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFActiveStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
        )
        var is_active pgtype.Bool
        err := row.Scan(&amp;is_active)
        return is_active, err
}</span>

const getWFInternalStatus = `-- name: GetWFInternalStatus :one
SELECT is_internal
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND brwf = 'W'
    AND setname = $4
`

type GetWFInternalStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFInternalStatus(ctx context.Context, arg GetWFInternalStatusParams) (bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFInternalStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
        )
        var is_internal bool
        err := row.Scan(&amp;is_internal)
        return is_internal, err
}</span>

const workFlowNew = `-- name: WorkFlowNew :one
INSERT INTO
    ruleset (
        realm, slice, app, brwf, class, setname, is_active, is_internal, ruleset, createdat, createdby
    )
VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP, $10
    )
RETURNING
    id
`

type WorkFlowNewParams struct {
        Realm      int32       `json:"realm"`
        Slice      int32       `json:"slice"`
        App        string      `json:"app"`
        Brwf       BrwfEnum    `json:"brwf"`
        Class      string      `json:"class"`
        Setname    string      `json:"setname"`
        IsActive   pgtype.Bool `json:"is_active"`
        IsInternal bool        `json:"is_internal"`
        Ruleset    []byte      `json:"ruleset"`
        Createdby  string      `json:"createdby"`
}

func (q *Queries) WorkFlowNew(ctx context.Context, arg WorkFlowNewParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, workFlowNew,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Brwf,
                arg.Class,
                arg.Setname,
                arg.IsActive,
                arg.IsInternal,
                arg.Ruleset,
                arg.Createdby,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const workflowget = `-- name: Workflowget :one
select
    id,
    slice,
    app,
    class,
    setname as name,
    is_active,
    is_internal,
    ruleset as flowrules,
    createdat,
    createdby,
    editedat,
    editedby
from ruleset
where
    slice = $1
    and app = $2
    and class = $3
    and setname = $4
`

type WorkflowgetParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
}

type WorkflowgetRow struct {
        ID         int32            `json:"id"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Name       string           `json:"name"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Flowrules  []byte           `json:"flowrules"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

func (q *Queries) Workflowget(ctx context.Context, arg WorkflowgetParams) (WorkflowgetRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, workflowget,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
        )
        var i WorkflowgetRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Name,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Flowrules,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: schema.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const schemaDelete = `-- name: SchemaDelete :one
DELETE FROM
    schema
WHERE
    id = $1 RETURNING id
`

func (q *Queries) SchemaDelete(ctx context.Context, id int32) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, schemaDelete, id)
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaGet = `-- name: SchemaGet :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    slice = $1
    AND class = $2
    AND app = $3
`

type SchemaGetParams struct {
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

type SchemaGetRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaGet(ctx context.Context, arg SchemaGetParams) ([]SchemaGetRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaGet, arg.Slice, arg.Class, arg.App)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaGetRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaGetRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaList = `-- name: SchemaList :many
SELECT
    schema.slice,
    realmslice.descr,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
`

type SchemaListRow struct {
        Slice     int32            `json:"slice"`
        Descr     string           `json:"descr"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaList(ctx context.Context) ([]SchemaListRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.Descr,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListByApp = `-- name: SchemaListByApp :many
SELECT
    schema.slice,
    realmslice.descr,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    app = $1
`

type SchemaListByAppRow struct {
        Slice     int32            `json:"slice"`
        Descr     string           `json:"descr"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListByApp(ctx context.Context, app string) ([]SchemaListByAppRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListByApp, app)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListByAppRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListByAppRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.Descr,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListByAppAndClass = `-- name: SchemaListByAppAndClass :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    app = $1
    AND class = $2
`

type SchemaListByAppAndClassParams struct {
        App   string `json:"app"`
        Class string `json:"class"`
}

type SchemaListByAppAndClassRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListByAppAndClass(ctx context.Context, arg SchemaListByAppAndClassParams) ([]SchemaListByAppAndClassRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListByAppAndClass, arg.App, arg.Class)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListByAppAndClassRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListByAppAndClassRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListByAppAndSlice = `-- name: SchemaListByAppAndSlice :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    app = $1
    AND slice = $2
`

type SchemaListByAppAndSliceParams struct {
        App   string `json:"app"`
        Slice int32  `json:"slice"`
}

type SchemaListByAppAndSliceRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListByAppAndSlice(ctx context.Context, arg SchemaListByAppAndSliceParams) ([]SchemaListByAppAndSliceRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListByAppAndSlice, arg.App, arg.Slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListByAppAndSliceRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListByAppAndSliceRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListByClass = `-- name: SchemaListByClass :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    class = $1
`

type SchemaListByClassRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListByClass(ctx context.Context, class string) ([]SchemaListByClassRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListByClass, class)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListByClassRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListByClassRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListByClassAndSlice = `-- name: SchemaListByClassAndSlice :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    class = $1
    AND slice = $2
`

type SchemaListByClassAndSliceParams struct {
        Class string `json:"class"`
        Slice int32  `json:"slice"`
}

type SchemaListByClassAndSliceRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListByClassAndSlice(ctx context.Context, arg SchemaListByClassAndSliceParams) ([]SchemaListByClassAndSliceRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListByClassAndSlice, arg.Class, arg.Slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListByClassAndSliceRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListByClassAndSliceRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaListBySlice = `-- name: SchemaListBySlice :many
SELECT
    schema.slice,
    schema.app,
    app.longname,
    schema.class,
    schema.createdby,
    schema.createdat,
    schema.editedby,
    schema.editedat
FROM
    schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    slice = $1
`

type SchemaListBySliceRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaListBySlice(ctx context.Context, slice int32) ([]SchemaListBySliceRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, schemaListBySlice, slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []SchemaListBySliceRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i SchemaListBySliceRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaNew = `-- name: SchemaNew :one
INSERT INTO
    schema (
        realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby
    )
VALUES (
        $1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP, $8
    )
RETURNING
    id
`

type SchemaNewParams struct {
        Realm         int32    `json:"realm"`
        Slice         int32    `json:"slice"`
        App           string   `json:"app"`
        Brwf          BrwfEnum `json:"brwf"`
        Class         string   `json:"class"`
        Patternschema []byte   `json:"patternschema"`
        Actionschema  []byte   `json:"actionschema"`
        Createdby     string   `json:"createdby"`
}

func (q *Queries) SchemaNew(ctx context.Context, arg SchemaNewParams) (int32, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, schemaNew,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Brwf,
                arg.Class,
                arg.Patternschema,
                arg.Actionschema,
                arg.Createdby,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaUpdate = `-- name: SchemaUpdate :one
UPDATE schema
SET
    brwf = $4,
    patternschema = $5,
    actionschema = $6,
    editedat = CURRENT_TIMESTAMP,
    editedby = $7
WHERE
    slice = $1
    AND class = $2
    AND app = $3
RETURNING
    id
`

type SchemaUpdateParams struct {
        Slice         int32       `json:"slice"`
        Class         string      `json:"class"`
        App           string      `json:"app"`
        Brwf          BrwfEnum    `json:"brwf"`
        Patternschema []byte      `json:"patternschema"`
        Actionschema  []byte      `json:"actionschema"`
        Editedby      pgtype.Text `json:"editedby"`
}

func (q *Queries) SchemaUpdate(ctx context.Context, arg SchemaUpdateParams) (int32, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, schemaUpdate,
                arg.Slice,
                arg.Class,
                arg.App,
                arg.Brwf,
                arg.Patternschema,
                arg.Actionschema,
                arg.Editedby,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const updateSchemaWithLock = `-- name: UpdateSchemaWithLock :one
SELECT
    brwf,
    patternschema,
    actionschema,
    editedat = CURRENT_TIMESTAMP,
    editedby
FROM schema
WHERE
    slice = $1
    AND class = $2
    AND app = $3
FOR UPDATE
`

type UpdateSchemaWithLockParams struct {
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

type UpdateSchemaWithLockRow struct {
        Brwf          BrwfEnum    `json:"brwf"`
        Patternschema []byte      `json:"patternschema"`
        Actionschema  []byte      `json:"actionschema"`
        Column4       bool        `json:"column_4"`
        Editedby      pgtype.Text `json:"editedby"`
}

func (q *Queries) UpdateSchemaWithLock(ctx context.Context, arg UpdateSchemaWithLockParams) (UpdateSchemaWithLockRow, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, updateSchemaWithLock, arg.Slice, arg.Class, arg.App)
        var i UpdateSchemaWithLockRow
        err := row.Scan(
                &amp;i.Brwf,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Column4,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const wfPatternSchemaGet = `-- name: WfPatternSchemaGet :one
SELECT
    patternschema
FROM
    public.schema
WHERE
    slice = $1
    AND class = $2
    AND app = $3
`

type WfPatternSchemaGetParams struct {
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

func (q *Queries) WfPatternSchemaGet(ctx context.Context, arg WfPatternSchemaGetParams) ([]byte, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfPatternSchemaGet, arg.Slice, arg.Class, arg.App)
        var patternschema []byte
        err := row.Scan(&amp;patternschema)
        return patternschema, err
}</span>

const wfschemadelete = `-- name: Wfschemadelete :exec
DELETE from
    schema
where
    id in (
        SELECT
            a.id
        FROM
            schema as a,
            realm as b,
            realmslice as c
        WHERE
            a.realm = b.id
            and a.slice = c.id
            and a.slice = $1
            and c.realm = b.shortname
            and a.class = $3
            AND a.app = $2
    )
`

type WfschemadeleteParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
}

func (q *Queries) Wfschemadelete(ctx context.Context, arg WfschemadeleteParams) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, wfschemadelete, arg.Slice, arg.App, arg.Class)
        return err
}</span>

const wfschemaget = `-- name: Wfschemaget :one
SELECT s.slice, s.app, s.class, rm.longname, s.patternschema, s.actionschema, s.createdat, s.createdby, s.editedat, s.editedby
FROM schema as s, realm as rm, realmslice as rs
WHERE
    s.realm = rm.id
    and s.slice = rs.id
    and s.slice = $1
    and rs.realm = rm.shortname
    and s.class = $3
    AND s.app = $2
`

type WfschemagetParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
}

type WfschemagetRow struct {
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Class         string           `json:"class"`
        Longname      string           `json:"longname"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) Wfschemaget(ctx context.Context, arg WfschemagetParams) (WfschemagetRow, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, wfschemaget, arg.Slice, arg.App, arg.Class)
        var i WfschemagetRow
        err := row.Scan(
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Longname,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: wfinstance.sql

package sqlc

import (
        "context"
)

const addWFNewInstace = `-- name: AddWFNewInstace :one
INSERT INTO 
wfinstance
(entityid,slice, app, class, workflow, step,loggedat, nextstep)
VALUES ($1,$2,$3,$4,$5,$6,(NOW() :: timestamp),$7) 
RETURNING id
`

type AddWFNewInstaceParams struct {
        Entityid string `json:"entityid"`
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Class    string `json:"class"`
        Workflow string `json:"workflow"`
        Step     string `json:"step"`
        Nextstep string `json:"nextstep"`
}

func (q *Queries) AddWFNewInstace(ctx context.Context, arg AddWFNewInstaceParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, addWFNewInstace,
                arg.Entityid,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Workflow,
                arg.Step,
                arg.Nextstep,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const getWFINstance = `-- name: GetWFINstance :many

SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent 
FROM wfinstance
WHERE slice = $1 
AND app = $2
AND workflow = $3
AND entityid = $4
`

type GetWFINstanceParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        Entityid string `json:"entityid"`
}

func (q *Queries) GetWFINstance(ctx context.Context, arg GetWFINstanceParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWFINstance,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.Entityid,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package schema

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/types"
)

// SchemaDelete will be responsible for processing the /WFschemaDelete request that comes through as a POST
func SchemaDelete(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        lh := s.LogHarbour
        lh.Log("SchemaDelete request received")

        // var response schemaGetResp
        var request SchemaGetReq
        err := wscutils.BindJSON(c, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("error while binding json request error:", err.Error)
                return
        }</span>

        <span class="cov8" title="1">valError := wscutils.WscValidate(request, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">if len(valError) &gt; 0 </span><span class="cov8" title="1">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, valError))
                lh.Debug0().LogActivity("validation error:", valError)
                return
        }</span>
        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>
        <span class="cov8" title="1">err = query.Wfschemadelete(c, sqlc.WfschemadeleteParams{
                Slice: request.Slice,
                App:   request.App,
                Class: request.Class,
        })
        if err != nil </span><span class="cov0" title="0">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{wscutils.BuildErrorMessage(types.OPERATION_FAILED, nil)}))
                lh.Debug0().LogActivity("failed while deleting record:", err.Error)
                return
        }</span>

        // lh.ChangeMinLogPriority(logharbour.LogPriority(logharbour.Change))
        <span class="cov8" title="1">lh.Log(fmt.Sprintf("Record delete: %v", map[string]any{"err": err}))
        wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(err))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package schema

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/types"
)

type SchemaGetReq struct {
        Slice int32  `json:"slice" validate:"required,gt=0"`
        App   string `json:"app" validate:"required,alpha"`
        Class string `json:"class" validate:"required,alpha"`
}

// SchemaGet will be responsible for processing the /wfschemaget request that comes through as a POST
func SchemaGet(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        lh := s.LogHarbour
        lh.Log("SchemaGet request received")

        var request SchemaGetReq
        // step 1: json request binding with a struct
        err := wscutils.BindJSON(c, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("error while binding json request error:", err.Error())
                return
        }</span>

        // step 2: standard validation
        <span class="cov8" title="1">valError := wscutils.WscValidate(request, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">if len(valError) &gt; 0 </span><span class="cov8" title="1">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, valError))
                lh.Debug0().LogActivity("validation error:", valError)
                return
        }</span>
        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>
        <span class="cov8" title="1">dbResponse, err := query.Wfschemaget(c, sqlc.WfschemagetParams{
                Slice: request.Slice,
                App:   request.App,
                Class: request.Class,
        })
        if err != nil </span><span class="cov0" title="0">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{wscutils.BuildErrorMessage(types.RECORD_NOT_EXIST, nil)}))
                lh.Debug0().LogActivity("failed to get data from DB:", err.Error())
                return
        }</span>

        <span class="cov8" title="1">lh.Log(fmt.Sprintf("Record found: %v", map[string]any{"response": dbResponse}))
        wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(dbResponse))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package schema

import (
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"

        "github.com/remiges-tech/crux/db/sqlc-gen"
)

func SchemaList(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Log("Starting execution of SchemaList()")
        var sh SchemaListStruct

        //check the deactivated table to check whether first, the realm and then, the user has been
        //  deactivated
        // isDeactivated()

        // check the capgrant table to see if the calling user has the capability to perform the
        // operation
        // isCapable, _ := utils.Authz_check(types.OpReq{
        //         User:      username,
        //         CapNeeded: []string{"report","ruleset","schema"},
        // }, false)

        // if !isCapable {
        //         l.Log("Unauthorized user:")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(utils.ErrUnauthorized))
        //         return
        // }

        err := wscutils.BindJSON(c, &amp;sh)
        if err != nil </span><span class="cov8" title="1">{
                l.LogActivity("Error Unmarshalling Query paramaeters to struct:", err.Error())
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">validationErrors := wscutils.WscValidate(sh, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>
        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>

        <span class="cov8" title="1">switch true </span>{
        case sh.App != nil &amp;&amp; sh.Class == nil &amp;&amp; sh.Slice == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListByApp(c, *sh.App)
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by app", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.Class != nil &amp;&amp; sh.App == nil &amp;&amp; sh.Slice == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListByClass(c, *sh.Class)
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by class", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.Slice != nil &amp;&amp; sh.Class == nil &amp;&amp; sh.App == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListBySlice(c, *sh.Slice)
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by slice", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.App != nil &amp;&amp; sh.Class != nil &amp;&amp; sh.Slice == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListByAppAndClass(c, sqlc.SchemaListByAppAndClassParams{App: *sh.App, Class: *sh.Class})
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by app &amp; class", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.App != nil &amp;&amp; sh.Slice != nil &amp;&amp; sh.Class == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListByAppAndSlice(c, sqlc.SchemaListByAppAndSliceParams{App: *sh.App, Slice: *sh.Slice})
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by app &amp; slice", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.Class != nil &amp;&amp; sh.Slice != nil &amp;&amp; sh.App == nil:<span class="cov8" title="1">
                schemaList, err := query.SchemaListByClassAndSlice(c, sqlc.SchemaListByClassAndSliceParams{Class: *sh.Class, Slice: *sh.Slice})
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by class &amp; slice", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        case sh.App != nil &amp;&amp; sh.Class != nil &amp;&amp; sh.Slice != nil:<span class="cov8" title="1">
                Schema, err := query.SchemaGet(c, sqlc.SchemaGetParams{App: *sh.App, Class: *sh.Class, Slice: *sh.Slice})
                if err != nil </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by app, class &amp; slice", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                        return
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: Schema, Messages: nil})</span>

        default:<span class="cov8" title="1">
                schemaList, err := query.SchemaList(c)
                if err != nil || len(schemaList) == 0 </span><span class="cov0" title="0">{
                        l.LogActivity("Error while retrieving schema list by app, class &amp; slice", err)
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                }</span>
                <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: schemaList, Messages: nil})</span>
        }

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package schema

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/types"
)

const (
        createdBy = "admin"
        realmID   = 1
)

func SchemaNew(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Log("Starting execution of SchemaNew()")

        var sh Schema

        err := wscutils.BindJSON(c, &amp;sh)
        if err != nil </span><span class="cov8" title="1">{
                l.LogActivity("Error Unmarshalling Query parameters to struct:", err.Error())
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">validationErrors := wscutils.WscValidate(sh, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">customValidationErrors := customValidationErrors(sh)
        validationErrors = append(validationErrors, customValidationErrors...)
        if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>

        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>
        <span class="cov8" title="1">patternSchema, err := json.Marshal(sh.PatternSchema)
        if err != nil </span><span class="cov0" title="0">{
                patternSchema := "patternSchema"
                l.LogDebug("Error while marshaling patternSchema", err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{wscutils.BuildErrorMessage(wscutils.ErrcodeInvalidJson, &amp;patternSchema)}))
                return
        }</span>

        <span class="cov8" title="1">actionSchema, err := json.Marshal(sh.ActionSchema)
        if err != nil </span><span class="cov0" title="0">{
                actionSchema := "actionSchema"
                l.LogDebug("Error while marshaling actionSchema", err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{wscutils.BuildErrorMessage(wscutils.ErrcodeInvalidJson, &amp;actionSchema)}))
                return
        }</span>
        <span class="cov8" title="1">_, err = query.SchemaNew(c, sqlc.SchemaNewParams{Realm: realmID, Slice: sh.Slice, Class: sh.Class, App: sh.App, Brwf: "W", Patternschema: patternSchema, Actionschema: actionSchema, Createdby: createdBy})
        if err != nil </span><span class="cov0" title="0">{
                l.LogActivity("Error while creating schema", err.Error())
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>
        <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: "Created successfully", Messages: nil})
        l.Log("Finished execution of SchemaNew()")</span>
}

func customValidationErrors(sh Schema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        patternSchemaError := verifyPatternSchema(sh.PatternSchema)
        validationErrors = append(validationErrors, patternSchemaError...)

        actionSchemaError := verifyActionSchema(sh.ActionSchema)
        validationErrors = append(validationErrors, actionSchemaError...)
        return validationErrors
}</span>

func verifyPatternSchema(ps types.PatternSchema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        re := regexp.MustCompile(cruxIDRegExp)

        for i, attrSchema := range ps.Attr </span><span class="cov8" title="1">{
                i++
                if !re.MatchString(attrSchema.Name) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("attrSchema[%d].Name", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, attrSchema.Name)
                        validationErrors = append(validationErrors, vErr)
                }</span>
                <span class="cov8" title="1">if !validTypes[attrSchema.ValType] </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("attrSchema[%d].ValType", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, attrSchema.ValType)
                        validationErrors = append(validationErrors, vErr)
                }</span>
                <span class="cov8" title="1">if attrSchema.ValType == "enum" &amp;&amp; len(attrSchema.Vals) == 0 </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("attrSchema[%d].Vals", i)
                        vErr := wscutils.BuildErrorMessage("empty", &amp;fieldName)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">return validationErrors</span>
}

func verifyActionSchema(as types.ActionSchema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        re := regexp.MustCompile(cruxIDRegExp)
        for i, task := range as.Tasks </span><span class="cov8" title="1">{
                if !re.MatchString(task) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("actionSchema.Tasks[%d]", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, task)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">for i, propName := range as.Properties </span><span class="cov8" title="1">{
                if !re.MatchString(propName) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("actionSchema.Properties[%d]", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, propName)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">return validationErrors</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package schema

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/logharbour/logharbour"
)

const (
        setBy        = "admin"
        brwf         = "W"
        editedBy     = "admin"
        cruxIDRegExp = `^[a-z][a-z0-9_]*$`
)

var validTypes = map[string]bool{
        "int": true, "float": true, "str": true, "enum": true, "bool": true, "timestamps": true,
}

func SchemaUpdate(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Log("Starting execution of SchemaUpdate()")

        var sh updateSchema
        
        err := wscutils.BindJSON(c, &amp;sh)
        if err != nil </span><span class="cov8" title="1">{
                l.LogActivity("Error Unmarshalling Query paramaeters to struct:", err.Error())
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">validationErrors := wscutils.WscValidate(sh, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">customValidationErrors := customValidationErrorsForUpdate(sh)
        validationErrors = append(validationErrors, customValidationErrors...)
        if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>

        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>

        <span class="cov8" title="1">connpool, ok := s.Database.(*pgxpool.Pool)
        if !ok </span><span class="cov0" title="0">{
                l.Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>

        <span class="cov8" title="1">err = schemaUpdateWithTX(c, query, connpool, l, sh)
        if err != nil </span><span class="cov0" title="0">{
                l.LogActivity("Error while Updating schema", err.Error())
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(wscutils.ErrcodeDatabaseError))
                return
        }</span>
        <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: "updated successfully", Messages: nil})
        l.Log("Starting execution of SchemaUpdate()")</span>
}

func schemaUpdateWithTX(c context.Context, query *sqlc.Queries, connpool *pgxpool.Pool, l *logharbour.Logger, sh updateSchema) error <span class="cov8" title="1">{
        patternSchema, err := json.Marshal(sh.PatternSchema)
        if err != nil </span><span class="cov0" title="0">{
                l.LogDebug("Error while marshaling patternSchema", err)
                return err
        }</span>

        <span class="cov8" title="1">actionSchema, err := json.Marshal(sh.ActionSchema)
        if err != nil </span><span class="cov0" title="0">{
                l.LogDebug("Error while marshaling actionSchema", err)
                return err
        }</span>

        <span class="cov8" title="1">tx, err := connpool.Begin(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(c)
        qtx := query.WithTx(tx)
        schema, err := qtx.UpdateSchemaWithLock(c, sqlc.UpdateSchemaWithLockParams{
                Slice: sh.Slice,
                Class: sh.Class,
                App:   sh.App,
        })
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback(c)
                return err
        }</span>
        <span class="cov8" title="1">if patternSchema != nil &amp;&amp; actionSchema == nil </span><span class="cov0" title="0">{
                _, err = qtx.SchemaUpdate(c, sqlc.SchemaUpdateParams{
                        Slice:         sh.Slice,
                        Class:         sh.Class,
                        App:           sh.App,
                        Brwf:          brwf,
                        Patternschema: schema.Patternschema,
                        Actionschema:  actionSchema,
                        Editedby:      pgtype.Text{String: editedBy},
                })
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback(c)
                        return err
                }</span>
        } else<span class="cov8" title="1"> if actionSchema != nil &amp;&amp; patternSchema == nil </span><span class="cov0" title="0">{
                _, err = qtx.SchemaUpdate(c, sqlc.SchemaUpdateParams{
                        Slice:         sh.Slice,
                        Class:         sh.Class,
                        App:           sh.App,
                        Brwf:          brwf,
                        Patternschema: schema.Patternschema,
                        Actionschema:  actionSchema,
                        Editedby:      pgtype.Text{String: editedBy},
                })
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback(c)
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                _, err = qtx.SchemaUpdate(c, sqlc.SchemaUpdateParams{
                        Slice:         sh.Slice,
                        Class:         sh.Class,
                        App:           sh.App,
                        Brwf:          brwf,
                        Patternschema: schema.Patternschema,
                        Actionschema:  schema.Actionschema,
                        Editedby:      pgtype.Text{String: editedBy},
                })
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback(c)
                        return err
                }</span>

        }

        <span class="cov8" title="1">if err := tx.Commit(c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">l.LogDataChange("Updated schema", logharbour.ChangeInfo{
                Entity:    "schema",
                Operation: "Update",
                Changes: []logharbour.ChangeDetail{
                        {
                                Field:    "patternSchema",
                                OldValue: string(schema.Patternschema),
                                NewValue: patternSchema},
                        {
                                Field:    "actionSchema",
                                OldValue: string(schema.Actionschema),
                                NewValue: actionSchema},
                },
        })

        return nil</span>
}

func customValidationErrorsForUpdate(sh updateSchema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        if sh.PatternSchema != nil &amp;&amp; sh.ActionSchema == nil </span><span class="cov0" title="0">{
                patternSchemaError := verifyPatternSchemaUpdate(sh.PatternSchema)
                validationErrors = append(validationErrors, patternSchemaError...)
        }</span> else<span class="cov8" title="1"> if sh.ActionSchema != nil &amp;&amp; sh.PatternSchema == nil </span><span class="cov0" title="0">{
                actionSchemaError := verifyActionSchemaUpdate(sh.ActionSchema)
                validationErrors = append(validationErrors, actionSchemaError...)
        }</span> else<span class="cov8" title="1"> if sh.PatternSchema == nil &amp;&amp; sh.ActionSchema == nil </span><span class="cov0" title="0">{
                fieldName := fmt.Sprintln("PatternSchema/ActionSchema")
                vErr := wscutils.BuildErrorMessage("at_least_one_must_be_supplied", &amp;fieldName)
                validationErrors = append(validationErrors, vErr)
        }</span> else<span class="cov8" title="1"> {
                patternSchemaError := verifyPatternSchemaUpdate(sh.PatternSchema)
                validationErrors = append(validationErrors, patternSchemaError...)
                actionSchemaError := verifyActionSchemaUpdate(sh.ActionSchema)
                validationErrors = append(validationErrors, actionSchemaError...)
        }</span>

        <span class="cov8" title="1">return validationErrors</span>
}
func verifyPatternSchemaUpdate(ps *patternSchema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        re := regexp.MustCompile(cruxIDRegExp)

        for i, attrSchema := range ps.Attr </span><span class="cov8" title="1">{
                i++
                if !re.MatchString(attrSchema.Name) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("attrSchema[%d].Name", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, attrSchema.Name)
                        validationErrors = append(validationErrors, vErr)
                }</span>
                <span class="cov8" title="1">if !validTypes[attrSchema.ValType] </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("attrSchema[%d].ValType", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, attrSchema.ValType)
                        validationErrors = append(validationErrors, vErr)
                }</span>
                <span class="cov8" title="1">if attrSchema.ValType == "enum" &amp;&amp; len(attrSchema.Vals) == 0 </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("attrSchema[%d].Vals", i)
                        vErr := wscutils.BuildErrorMessage("empty", &amp;fieldName)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">return validationErrors</span>
}

func verifyActionSchemaUpdate(as *actionSchema) []wscutils.ErrorMessage <span class="cov8" title="1">{
        var validationErrors []wscutils.ErrorMessage
        re := regexp.MustCompile(cruxIDRegExp)

        for i, task := range as.Tasks </span><span class="cov8" title="1">{
                if !re.MatchString(task) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("actionSchema.Tasks[%d]", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, task)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">for i, propName := range as.Properties </span><span class="cov8" title="1">{
                if !re.MatchString(propName) </span><span class="cov8" title="1">{
                        fieldName := fmt.Sprintf("actionSchema.Properties[%d]", i)
                        vErr := wscutils.BuildErrorMessage("not_valid", &amp;fieldName, propName)
                        validationErrors = append(validationErrors, vErr)
                }</span>
        }
        <span class="cov8" title="1">return validationErrors</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"

        "github.com/remiges-tech/alya/wscutils"
)

func MarshalJson(data any) []byte <span class="cov8" title="1">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov8" title="1">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov8" title="1">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov8" title="1">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return jsonData, nil</span>
}

type TestCasesStruct struct {
        Name             string
        RequestPayload   wscutils.Request
        ExpectedHttpCode int
        TestJsonFile     string
        ExpectedResult   *wscutils.Response
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"

        "github.com/go-playground/validator/v10"
)

const (
        DevEnv           Environment = "dev_env"
        ProdEnv          Environment = "prod_env"
        UATEnv           Environment = "uat_env"
        RECORD_NOT_EXIST             = "record_does_not_exist"
        OPERATION_FAILED             = "operation_failed"
)

var APP, SLICE, CLASS, NAME string = "App", "Slice", "Class", "Name"

type Environment string

type OpReq struct {
        User      string   `json:"user"`
        CapNeeded []string `json:"capNeeded"`
        Scope     Scope    `json:"scope"`
        Limit     Limit    `json:"limit"`
}

type Scope map[string]interface{}
type Limit map[string]interface{}

type QualifiedCap struct {
        Id    string `json:"id"`
        Cap   string `json:"cap"`
        Scope Scope  `json:"scope"`
        Limit Limit  `json:"limit"`
}

type Capabilities struct {
        Name          string         `json:"name"` //either user name or group name
        QualifiedCaps []QualifiedCap `json:"qualifiedCaps"`
}

type Attribute struct {
        Name      string   `json:"name" validate:"required"`
        ShortDesc string   `json:"shortdesc" validate:"required"`
        LongDesc  string   `json:"longdesc" validate:"required"`
        ValType   string   `json:"valtype" validate:"required"`
        Vals      []string `json:"vals,omitempty"`
        Enumdesc  []string `json:"enumdesc,omitempty"`
        ValMax    *int32   `json:"valmax,omitempty"`
        ValMin    *int32   `json:"valmin,omitempty"`
        LenMax    *int32   `json:"lenmax,omitempty"`
        LenMin    *int32   `json:"lenmin,omitempty"`
}

type PatternSchema struct {
        Class string      `json:"class" validate:"required,lowercase"`
        Attr  []Attribute `json:"attr" validate:"required,dive"`
}

type ActionSchema struct {
        Class      string   `json:"class" validate:"required,lowercase"`
        Tasks      []string `json:"tasks" validate:"required"`
        Properties []string `json:"properties" validate:"required"`
}


func (env Environment) IsValid() bool <span class="cov0" title="0">{
        switch env </span>{
        case DevEnv, ProdEnv, UATEnv:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CommonValidation is a generic function which setup standard validation utilizing
// validator package and Maps the errorVals based on the map parameter and
// return []errorVals
func CommonValidation(err validator.FieldError) []string <span class="cov0" title="0">{
        var vals []string
        switch err.Tag() </span>{
        case "required":<span class="cov0" title="0">
                vals = append(vals, "not_provided")</span>
        case "alpha":<span class="cov0" title="0">
                vals = append(vals, "only_alphabets_are_allowed")</span>
        case "gt":<span class="cov0" title="0">
                vals = append(vals, "must_be_greater_than_zero")</span>
        default:<span class="cov0" title="0">
                vals = append(vals, "not_valid_input")</span>
        }
        <span class="cov0" title="0">return vals</span>
}

func MarshalJson(data any) []byte <span class="cov8" title="1">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov8" title="1">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov8" title="1">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov8" title="1">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return jsonData, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
